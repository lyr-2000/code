<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>堆 on 凌冬的代码博客站</title><link>https://lyr-2000.github.io/code/tags/%E5%A0%86/</link><description>Recent content in 堆 on 凌冬的代码博客站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>LYR</copyright><lastBuildDate>Sat, 02 Mar 2024 23:41:54 +0000</lastBuildDate><atom:link href="https://lyr-2000.github.io/code/tags/%E5%A0%86/index.xml" rel="self" type="application/rss+xml"/><item><title>优先队列&amp;堆库详解</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E5%BA%93%E8%AF%A6%E8%A7%A3/</link><pubDate>Sat, 02 Mar 2024 23:41:54 +0000</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E5%BA%93%E8%AF%A6%E8%A7%A3/</guid><description>优先队列 [[....\图论\最短路径问题\迪杰斯特拉详解.md]] 请你实现一个堆(大根堆)。 操作： push x：将 x加入堆。保证 x为int型整数。不</description></item><item><title>lc.2500.删除每行的最大值</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/lc.2500.%E5%88%A0%E9%99%A4%E6%AF%8F%E8%A1%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link><pubDate>Sun, 21 Jan 2024 19:03:32 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/lc.2500.%E5%88%A0%E9%99%A4%E6%AF%8F%E8%A1%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid><description>leetcode 2500.删除每行中的最大值 algorithms Easy (83.75%) Likes: 59 Dislikes: 0 Total Accepted: 32.9K Total Submissions: 39.3K Testcase Example: &amp;lsquo;[[1,2,4],[3,3,1]]&amp;rsquo; 给你一个 m x n 大小的矩阵 grid ，由若干正整数组成。 执行下述操作，直到 grid 变为空矩阵：</description></item><item><title>lc.501.IPO</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/lc.501.ipo/</link><pubDate>Sun, 23 Oct 2022 13:58:05 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/lc.501.ipo/</guid><description>502. IPO Description Difficulty: 困难 Related Topics: 贪心 , 数组 , 排序 , 堆（优先队列） 假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO</description></item><item><title>347.前k个高频元素</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/347.%E9%AB%98%E9%A2%91%E6%95%B0%E5%AD%97/</link><pubDate>Sat, 11 Jun 2022 01:37:53 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/347.%E9%AB%98%E9%A2%91%E6%95%B0%E5%AD%97/</guid><description>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums =</description></item><item><title>23.合并前k个升序链表</title><link>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/23.%E5%90%88%E5%B9%B6%E5%89%8Dk%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 11 Jun 2022 01:24:49 +0800</pubDate><guid>https://lyr-2000.github.io/code/post/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/23.%E5%90%88%E5%B9%B6%E5%89%8Dk%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description>23. 合并K个升序链表 Description Difficulty: 困难 Related Topics: 链表 , 分治 , 堆（优先队列） , 归并排序 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链</description></item></channel></rss>